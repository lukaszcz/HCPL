/* logic.ipl: Basic illative logic constructs.
 *
 * Copyright (C) 2013 by Lukasz Czajka
 */

import List;

syntax operator -> is right, binary, after appl;

syntax operator in is left, binary, after =;
syntax operator : is left, binary, after =;
syntax operator => is right, binary, after or;
syntax operator <=> is right, binary, after =>;

syntax block proof qed;

syntax macrosep lemma;
syntax macrosep theorem;
syntax macrosep tactic;

let error2 = \p \msg { error (msg ^ ": " ^ (to_string p)) }

symbol Type
symbol Prop

symbol ALL
symbol EX
symbol ASSM
symbol VAR

let in = \x \y . y x
let : = (in)
let -> = \t1 \t2 \f (ALL t1 \x . f x in t2)
let => = \x \y . if x then y else true
let <=> = \x \y . (x => y) and (y => x)
let proof-of = \x (`__ipl_proof, x)
let goal = \p . match p with proof-of %x -> x | %_ -> error2 p "expected a proof"
let is-proof = \p . matches p (proof-of %_)


/*********************************************************************************/
/* helper functions & macros */

macro var-intro = \args {
   match args with
   | [%x, %b] ->
      #< { let #$0 = unique-int () in ((\#x #b) '(VAR #$0)) } >#
   | [%x, #< in >#, %b] ->
      #< { let #$0 = unique-int () in ((\#x #b) '(VAR #$0)) } >#
   | [%x] ->
      #< let #$0 = unique-int (); '(VAR #$0) >> \#x .. >#
   | %_ -> error "var-intro: wrong arguments"
}

let get-tactic-name = \tac { join-symbols tac (join-symbols #< - ># #< tactic >#) }

let mk-tactic-apply = \f \args { mk-apply f (#< __ipl_facts ># :: args) }

macro(2) mk-tactic-call = \x \y {
   let tac-id = get-tactic-name x
   let z = mk-tokens [tac-id]
   in
   #< mk-tactic-apply #z #y >#
}

macro(2) tactic = \id \eq-tok {
   if eq-tok /= #< = ># then
      error "tactic: expected '=' after tactic name"
   else {
      let tac-id = join-symbols id (join-symbols #< - ># #< tactic >#);
      #< macro #id = \args { mk-tactic-call #id args }; let #tac-id = \__ipl_facts >#
   }
}

macro call-tactic-with = \args {
   match args with
   | %tac :: %facts :: %t ->
      begin
         let t2 = join-tokens-list t
         let tac2 = get-tactic-name tac
         in
         #< #tac2 #facts #t2 >#
      end
   | %_ -> error "call-tactic-with: wrong arguments"
}

macro try-tactic = \args {
   match args with
   | %tac :: %t ->
      let rest = join-tokens-list t
      in
      #<
         begin
            try
               #tac #rest
            with %_ -> ()
         end
      >#
   | %_ -> error "try-tactic: wrong arguments"
}

let eval-limit = 1000
let eq-limit = 100

let eq-aux = \f \x \y {
   let aux0 = \x \y \lim0 {
      let aux = \x \y \lim {
         if f x y then
            true
         else if lim = 0 then {
            let xe = eval-limited x eval-limit;
            let ye = eval-limited y eval-limit;
            if f xe ye then
               true
            else {
               match xe, ye with
               | '(%a1 %b1), '(%a2 %b2) ->
                  aux0 a1 a2 (lim0 - 1) and aux0 b1 b2 (lim0 - 1)
               | '(\x %_), '(\x %_) ->
                  var-intro x {
                     aux0 '(xe x) '(ye x) (lim0 - 1)
                  }
               | %_ ->
                  false
            }
         } else {
           let rx = reduce x
           let ry = reduce y
           let xe = reduce-eta x
           let ye = reduce-eta y
           in
           if f rx y or f x ry or f xe y or f xe ry or f x ye or f rx ye then
              true
           else
              aux rx ry (lim - 1)
         }
      };
      if lim0 = 0 then
         false
      else
         aux x y 2
   };
   aux0 x y eq-limit
}

let eq = eq-aux (=)

let qmatches = eq-aux matches

let is-in-list = \lst \x {
   List.exists (eq x o goal) lst
}

let find-in-list = \lst \x {
   List.find (eq x o goal) lst ()
}

let check-in-list = \lst \x \emsg {
   let p = find-in-list lst x
   in
   if is-proof p then
      p
   else
      error2 x emsg
}

let match-in-list-acc = \lst \pat \acc {
   List.fold (\h . if qmatches (goal h) pat then h :: acc else acc) lst acc
}

let match-in-list = \lst \pat {
   match-in-list-acc lst pat []
}


/*********************************************************************************/
/* basic proof methods */

let pexpand = \a \p {
   let phi = goal p
   in
   if eq phi (reduce a) or eq phi (reduce-eta a) then
      proof-of a
   else
      error2 (phi, a) "cannot expand"
}

let preduce = \p {
   proof-of (reduce (goal p))
}

let preduce-eta = \p {
   proof-of (reduce-eta (goal p))
}

let peval = \p {
   proof-of (eval (goal p))
}

let peval-limited = \p \lim {
   proof-of (eval-limited (goal p) lim)
}

let __ipl_suppose_aux = \__ipl_facts \phi \f {
   let p = f ((proof-of phi) :: __ipl_facts)
   in
   match p with
   | proof-of %x -> proof-of '(ASSM phi x)
   | %_ -> error2 p "suppose: expected a proof"
}

macro suppose = \args {
   match args with
   | [%a] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts .. >#
   | [%name, #< : >#, %a] ->
      #< let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts .. >#
   | [%a, %b] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts { #b } >#
   | [%a, #< in >#, %b] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts { #b } >#
   | [%name, #< : >#, %a, %b] ->
      #< { let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts { #b } } >#
   | [%name, #< : >#, %a, #< in >#, %b] ->
      #< { let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts { #b } } >#
   | %_ -> error "suppose: wrong arguments"
};

let impl-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | ('(%b in Prop), '(ASSM %a %x)) ->
      if eq a b then
         proof-of '(a => x)
      else
         error2 p1 "impl-intro: bad typing derivation"
   | %_ -> error2 (p1, p2) "impl-intro: expected a typing derivation and a supposition"
}

let impl-elim = \p1 \p2 {
   let form = goal p2
   in
   match goal p1 with
   | '(form => %p) -> proof-of p
   | %_ -> error2 p1 "impl-elim: expected implication"
}

let impl-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi1 in Prop), '(ASSM %phi2 (%psi in Prop)) ->
      if eq phi1 phi2 then
         proof-of '((phi1 => psi) in Prop)
      else
         error2 phi2 "impl-type-intro: wrong argument"
   | '(%phi in Prop), '(%psi in Prop) -> proof-of '((phi => psi) in Prop)
   | %_ -> error2 (p1, p2) "impl-type-intro: wrong arguments"
}

let impl-type-elim = \p {
   match goal p with
   | '((%a => %_) in Prop) -> proof-of '(a in Prop)
   | %_ -> error2 p "impl-type-elim: wrong argument"
}

let forall-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) %app)) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '(ALL a1 phi)
            | %_ -> error2 p2 "forall-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "forall-intro: wrong arguments"
   }
};

let forall-elim = \p1 \p2 {
   match goal p1, goal p2 with
   | ('(ALL %a %phi), '(%t in %a1)) when eq a a1 ->
      proof-of '(phi t)
   | ('(ALL %a %phi), '(%a1 %t)) when eq a a1 ->
      proof-of '(phi t)
   | %_ -> error2 (p1, p2) "forall-elim: wrong arguments"
};

let forall-type-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) (%app in Prop))) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '((ALL a1 phi) in Prop)
            | %_ -> error2 p2 "forall-type-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "forall-type-intro: wrong arguments"
   }
};

let exists-intro = \p1 \p2 \p3 {
   match (goal p1, goal p2, goal p3) with
   | ('(%a in Type), '(%t in %a1), '(%phi %t1)) when eq a a1 and eq t t1 ->
      '(EX a phi)
   | %_ -> error2 (p1, p2, p3) "exists-intro: wrong arguments"
};

let exists-elim = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match (goal p1, goal p2) with
      | ('(EX %a %phi), '(ASSM (x in %a1) (ASSM %app %psi))) when eq a a1 ->
         if occurs-check x psi then
            error2 (p1, p2) "exists-elim: the variable quantified over cannot in the conclusion"
         else {
            match lift app x with
            | '(%phi1 x) when eq phi phi1 -> proof-of psi
            | %_ -> error2 p2 "exists-elim: bad proof"
         }
      | %_ -> error2 (p1, p2) "exists-elim: wrong arguments"
   }
};

let exists-type-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) (%app in Prop))) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '((EX a1 phi) in Prop)
            | %_ -> error2 p2 "exists-type-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "exists-type-intro: wrong arguments"
   }
}

let or-intro-left = \p \right {
   let left = goal p
   in
   proof-of '(left or right)
}

let or-intro-right = \left \p {
   let right = goal p
   in
   proof-of '(left or right)
}

let or-intro = \x \y {
   match x with
   | proof-of %phi -> or-intro-left x y
   | %_ -> or-intro-right x y
}

let or-elim = \p \p1 \p2 {
   match (goal p, goal p1, goal p2) with
   | ('(%a or %b), '(ASSM %a1 %c), '(ASSM %b1 %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(%a1 => %c), '(%b1 => %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(ASSM %a1 %c), '(%b1 => %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(%a1 => %c), '(ASSM %b1 %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | %_ -> error2 (p, p1, p2) "or-elim: wrong arguments"
}

let or-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi in Prop), '(%psi in Prop) -> proof-of '((phi or psi) in Prop)
   | %_ -> error2 (p1, p2) "or-type-intro: wrong arguments"
}

let and-intro = \p1 \p2 {
   let a = goal p1
   let b = goal p2
   in
   proof-of '(a and b)
}

let and-elim-left = \p {
   match goal p with
   | '(%a and %_) -> proof-of a
   | %_ -> error2 p "and-elim-left: wrong argument"
}

let and-elim-right = \p {
   match goal p with
   | '(%_ and %b) -> proof-of b
   | %_ -> error2 p "and-elim-right: wrong argument"
}

let and-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a in Prop), '(%b in Prop) -> proof-of '((a and b) in Prop)
   | %_ -> error2 (p1, p2) "and-type-intro: wrong arguments"
}

let equiv-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi => %psi), '(%psi1 => %phi1) when eq phi phi1 and eq psi psi1 -> proof-of '(phi <=> psi)
   | %_ -> error2 (p1, p2) "equiv-intro: wrong arguments"
}

let equiv-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi in Prop), '(%psi in Prop) ->
      proof-of '((phi <=> psi) in Prop)
   | '(ASSM %psi1 (%phi in Prop)), '(ASSM %phi1 (%psi in Prop)) when eq psi psi1 and eq phi phi1 ->
      proof-of '((phi <=> psi) in Prop)
   | '(ASSM %psi1 (%phi in Prop)), '(%psi in Prop) when eq psi psi1 ->
      proof-of '((phi <=> psi) in Prop)
   | '(%phi in Prop), '(ASSM %phi1 (%psi in Prop)) when eq phi phi1 ->
      proof-of '((phi <=> psi) in Prop)
   | %_ ->
      error2 (p1, p2) "equiv-type-intro: wrong arguments"
}

let equiv-elim = \p1 \p2 {
   match goal p1 with
   | '(%phi <=> %psi) when eq phi (goal p2) -> proof-of psi
   | '(%phi <=> %psi) when eq psi (goal p2) -> proof-of phi
}

let false-elim = \phi \p {
   match p with
   | proof-of false -> proof-of phi
   | %_ -> error2 p "false-elim: wrong argument"
}

let not-intro-2 = \p1 \p2 {
   match (goal p1, goal p2) with
   | ('(%a in Prop), '(ASSM %a1 false)) when eq a a1 ->
      proof-of '(not a)
   | %_ -> error2 (p1, p2) "not-intro-2: wrong arguments"
}

macro(1) not-intro-1 = \p #<{
   let #$0 = #p
   in
   match goal #$0 with
   | '(ASSM %a false) ->
      not-intro-2 (auto-type '(a in Prop)) #$0
   | %_ -> error2 #$0 "not-intro-1: wrong argument"
}>#

macro not-intro = \args {
   match args with
   | [%x] -> #< not-intro-1 #x >#
   | [%x, %y] -> #< not-intro-2 #x #y >#
   | %_ -> error "not-intro: wrong arguments"
}

let not-elim = \p1 \p2 {
   let a = goal p1;
   let b = goal p2;
   if eq a '(not b) or eq '(not a) b then
      proof-of false
   else
      error2 (p1, p2) "not-elim: wrong arguments"
}

let not-type-intro = \p {
   match goal p with
   | '(%g in Prop) -> proof-of '((not g) in Prop)
   | %_ -> error2 p "not-type-intro: wrong argument"
}

let not-type-elim = \p {
   match goal p with
   | '((not %a) in Prop) -> proof-of '(a in Prop)
   | %_ -> error2 p "not-type-elim: wrong argument"
}

let contradiction = \p {
   match goal p with
   | '((not %x) => false) -> proof-of x
   | '(not (not %x)) -> proof-of x
   | '((%x => false) => false) -> proof-of x
   | %_ -> error2 p "contradiction: wrong argument"
}

let prop-intro = \p {
   let phi = goal p
   in
   proof-of '(phi in Prop)
}

let prop-type-intro = proof-of '(Prop in Type)

let fun-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a in Type), '(%b in Type) -> proof-of '((a -> b) in Type)
   | %_ -> error2 (p1, p2) "fun-type-intro: wrong arguments"
}

let equal-intro = \a \b {
   if eq a b then
      proof-of '(a = b)
   else
      error2 (a, b) "equal-intro: not equal"
}

let equal-elim = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%phi %b1) when eq b b1 -> proof-of '(phi a)
   | %_ -> error2 (p1, p2) "equal-elim: wrong arguments"
}

let equal-sym = \p {
   match goal p with
   | '(%a = %b) -> proof-of '(b = a)
   | %_ -> error2 p "equal-sym: wrong argument"
}

let equal-trans = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%b1 = %c) when eq b b1 -> proof-of '(a = c)
   | %_ -> error2 (p1, p2) "equal-trans: wrong arguments"
}

let equal-cong = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%c = %d) -> proof-of '(a c = b d)
   | %_ -> error2 (p1, p2) "equal-cong: wrong arguments"
}

let bool-ext-true = \p {
   let g = goal p
   in
   proof-of '(g = true)
}

let bool-ext-false = \p {
   match goal p with
   | '(not %a) -> '(a = false)
   | %_ -> error2 p "bool-ext-false: wrong argument"
}

let false-type-intro = proof-of '(false in Prop)
let true-type-intro = proof-of '(true in Prop)

let true-intro = proof-of true

let faith = proof-of

macro(0) facts = \_ { #< __ipl_facts ># }

macro(1) fact = \phi #< check-in-list __ipl_facts #phi "not a known fact" >#
macro(1) is-fact = \x #< is-in-list __ipl_facts #x >#
macro(1) find-fact = \x #< find-in-list __ipl_facts #x >#
macro(1) match-facts = \pat #< match-in-list __ipl_facts #pat >#

macro(1) remember = \p #< let #$0 = #p in (#$0 :: __ipl_facts) >> \__ipl_facts .. #$0 >#

/*********************************************************************************/

let __ipl_facts = []


/*********************************************************************************/

let verify = \phi \p {
   if eq phi (goal p) then
      proof-of phi
   else
      error2 p ("not a proof of " ^ to_string phi)
}

/*********************************************************************************/
/* convenience macros */

macro assume = \args {
   let get-block = \lst {
      match List.rev lst with
      | %b :: #< in ># :: %_ -> b
      | %_ -> ()
   };
   let get-type = \lst {
      match List.rev lst with
      | %_ :: #< in ># :: %t -> join-tokens-list (List.rev t)
      | %_ -> join-tokens-list lst
   };
   let aux = \name \assm \tp \block {
      let tp2 = if tp = () then #< (auto-type '(#$0 in Prop)) ># else tp;
      if name = () and block = () then
         #< let #$0 = #assm in impl-intro #tp2 << __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts .. >#
      else if name = () then
         #< { let #$0 = #assm in impl-intro #tp2 (suppose #$0 #block) } >#
      else if block = () then
         #<
            let #$0 = #assm;
            let #name = proof-of #$0;
            impl-intro #tp2 << __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts ..
         >#
      else
         #< { let #$0 = #assm in impl-intro #tp2 (suppose #name : #$0 #block) } >#
   };
   match args with
   | [%a] ->
      aux () a () ()
   | [%name, #< : >#, %a] ->
      aux name a () ()
   | %name :: #< : ># :: %a :: #< with ># :: %t ->
      aux name a (get-type t) (get-block t)
   | [%name, #< : >#, %a, #< in >#, %b] ->
      aux name a () b
   | [%name, #< : >#, %a, %b] ->
      aux name a () b
   | %a :: #< with ># :: %t ->
      aux () a (get-type t) (get-block t)
   | [%a, %b] ->
      aux () a () b
   | [%a, #< in >#, %b] ->
      aux () a () b
   | %_ ->
      error "assume: wrong arguments"
};

macro fix = \args {
   let aux = \vars \tp \tp-deriv \body {
      match vars with
      | %h :: %t ->
         let r = aux t tp tp-deriv body
         in
         #< forall-intro #tp-deriv \#h .. suppose '(#h in #tp); #r >#
      | [] -> body
   };
   match List.split-once (= #< : >#) args with
   | [%lst1, %lst2] ->
      let vars =
         List.map (\x . match x with [%y] -> y | %_ -> error "fix: wrong arguments")
         <<
         List.split (= #< , >#) lst1
      in
      begin
         match List.split-once (= #< with >#) lst2 with
         | [%_] ->
            begin
               match List.split-once (= #< in >#) lst2 with
               | [%_] ->
                  let tp = join-tokens-list lst2
                  in
                  aux vars tp #< (auto-type '(#tp in Type)) ># #< >#
               | [%a, %b] ->
                  let tp = join-tokens-list a
                  in
                  let body = join-tokens-list b
                  in
                  let r = aux vars tp #< (auto-type '(#tp in Type)) ># body
                  in
                  #< (#r) >#
               | %_ -> error "fix: wrong arguments"
            end
         | [%lst3, %lst4] ->
            begin
               let tp = join-tokens-list lst3
               in
               match List.split-once (= #< in >#) lst4 with
               | [%_] ->
                  let tp-deriv = join-tokens-list lst4
                  in
                  aux vars tp tp-deriv #< >#
               | [%a, %b] ->
                  let tp-deriv = join-tokens-list a
                  in
                  let body = join-tokens-list b
                  in
                  let r = aux vars tp tp-deriv body
                  in
                  #< (#r) >#
               | %_ -> error "fix: wrong arguments"
            end
         | %_ -> error "fix: wrong arguments"
      end
   | %_ -> error "fix: wrong arguments"
};

macro obtain = \args {
   let aux = \v \p \b {
      if b = () then
         #<
            let #$0 = $p
            in
            exists-elim #p \#v ..
               let #$1 =
                  match goal #$0 with
                  | '(EX %alpha %phi) -> (alpha, phi)
                  | %_ -> error2 #$0 "obtain: expected a proof of an existential formula"
               in
               let #$2 = fst #$1;
               let #$3 = snd #$1;
               suppose '(#v in #$2);
               suppose '(#$3 #v);
         >#
      else
         #<{
            let #$0 = $p
            in
            exists-elim #p \#v {
               match goal #$0 with
               | '(EX %alpha %phi) ->
                  begin
                     suppose '(#v in alpha);
                     suppose '(phi #v);
                     #b
                  end
               | %_ ->
                  error2 #$0 "obtain: expected a proof of an existential formula"
            }
         }>#
   };
   match args with
   | %v :: #< from ># :: %t ->
      begin
         match List.split-once (= #< in >#) t with
         | [%_] ->
            let p = join-tokens-list t
            in
            aux v p ()
         | [%lst1, %lst2] ->
            let p = join-tokens-list lst1
            in
            let b = join-tokens-list lst2
            in
            aux v p b
         | %_ ->
            error "obtain: wrong arguments"
      end
   | [%v, %p, %b] ->
      aux v p b
   | [%v, %p] ->
      aux v p ()
   | %_ -> error "obtain: wrong arguments"
};

macro lemma = \args {
   match args with
   | [%name, %formula, %xproof] ->
      #<
         let #$0 = #formula;
         let #name = { let thesis = #$0; (#xproof) };
         remember (verify #$0 #name)
      >#
   | [%formula, %xproof] ->
      #<
         let #$0 = #formula;
         let #$1 = { let thesis = #$0; (#xproof) };
         remember (verify #$0 #$1)
      >#
   | %_ -> error "lemma: wrong arguments"
}

macro theorem = \args { mk-macro-call (lemma) args }

macro axiom = \args {
   match args with
   | [%phi] -> #< (proof-of #phi :: __ipl_facts) >> \__ipl_facts .. >#
   | %_ -> error "axiom: wrong arguments"
}

let __ipl_ex_all_aux = \args \quant \msg {
   match List.split-once (= #< : >#) args with
   | [%lst1, %lst2] ->
      begin
         let pr =
            begin
               match List.split-once (= #< . >#) lst2 with
               | [%_] ->
                  let len = List.length lst2
                  in
                  (join-tokens-list (List.head lst2 (len - 1)), List.nth lst2 (len - 1))
               | [%lst3, %lst4] ->
                  (join-tokens-list lst3, join-tokens-list lst4)
               | %_ -> error msg
            end
         in
         let tp = fst pr;
         let rest = snd pr;
         let aux = \lst {
            match lst with
            | [%x] :: %t ->
               join-tokens #< #quant (#tp) \#x . ># (aux t)
            | [] -> #< >#
            | %_ -> error msg
         };
         let h = aux (List.split (= #< , >#) lst1)
         in
         #< #h #rest >#
      end
   | %_ -> error msg
}

macro ex = \args { __ipl_ex_all_aux args #< EX ># "exists: wrong arguments" }
macro all = \args { __ipl_ex_all_aux args #< ALL ># "forall: wrong arguments" }

macro exists = \args { mk-macro-call ex args }
macro forall = \args { mk-macro-call all args }

macro show = \args {
   let aux = \name \formula \p {
      if name = () then
         #< remember (let #$0 = #formula in verify #$0 #p) >#
      else
         #< let #$0 = #formula in let #name = verify #$0 #p in remember #name >#
   };
   let pr =
      match args with
      | %name :: #< : ># :: %rest -> (name, rest)
      | %_ -> ((), args)
   in
   let name = fst pr
   let lst0 = snd pr
   in
   match lst0 with
   | %formula :: #< by ># :: %lst1 ->
      begin
         match lst1 with
         | %tac :: #< from ># :: %lst2 ->
            let facts = join-tokens-list lst2
            in
            aux name formula #< (call-tactic-with #tac [ #facts ] #$0) >#
         | [%tac] ->
            aux name formula #< (#tac #$0) >#
         | %_ ->
            error "show: wrong arguments"
      end
   | %formula :: #< with ># :: %lst1 ->
      let p = join-tokens-list lst1
      in
      aux name formula #< (#p) >#
   | %formula :: #< from ># :: %lst1 ->
      let facts = join-tokens-list lst1
      in
      aux name formula #< (call-tactic-with auto [ #facts ] #$0) >#
   | [%formula] ->
      aux name formula #< (auto #$0) >#
   | %_ ->
      error "show: wrong arguments"
};


/*********************************************************************************/
/* core proof tactics */

include "tactics/auto-type.ipl"
include "tactics/auto.ipl"
