/* logic.ipl: Illative logic implementation.
 *
 * Copyright (C) 2013 by Lukasz Czajka
 */

import List;

syntax operator -> is right, binary, after appl;

syntax operator in is left, binary, after =;
syntax operator : is left, binary, after =;
syntax operator => is right, binary, after or;
syntax operator <=> is right, binary, after =>;

syntax block proof qed;

syntax macrosep lemma;
syntax macrosep theorem;
syntax macrosep tactic;
syntax macrosep rule;

let error2 = \p \&#msg { error (msg ^ ": " ^ (to_string p)) }

symbol Type
symbol Prop

symbol ALL
symbol EX
symbol ASSM
symbol VAR

let in = \x \y . y x
let : = (in)
let -> = \t1 \t2 \f (ALL t1 \x . f x in t2)
let => = \x \y . if x then y else true
let <=> = \x \y . (x => y) and (y => x)
let proof-of = \x (`__ipl_proof, x)
let goal = \p { match p with proof-of %x -> x | %_ -> error2 p "expected a proof" }
let is-proof = \p . matches p (proof-of %_)


/*********************************************************************************/
/* helper functions & macros */

macro var-intro = \args {
   match args with
   | [%x, %b] ->
      #< { let #$0 = unique-int () in ((\#x #b) '(VAR #$0)) } >#
   | [%x, #< in >#, %b] ->
      #< { let #$0 = unique-int () in ((\#x #b) '(VAR #$0)) } >#
   | [%x] ->
      #< let #$0 = unique-int (); '(VAR #$0) >> \#x .. >#
   | %_ -> error "var-intro: wrong arguments"
}

let get-tactic-name = \tac { join-symbols tac (join-symbols #< - ># #< tactic >#) }
let get-rule-name = \tac { join-symbols tac (join-symbols #< - ># #< rule >#) }

let mk-tactic-apply = \f \args { mk-apply f (#< __ipl_facts ># :: args) }
let mk-rule-apply = mk-tactic-apply

macro(2) mk-tactic-call = \x \y {
   let tac-id = get-tactic-name x
   let z = mk-tokens [tac-id]
   in
   #< mk-tactic-apply #z #y >#
}

macro(2) mk-rule-call = \x \y {
   let tac-id = get-rule-name x
   let z = mk-tokens [tac-id]
   in
   #< mk-rule-apply #z #y >#
}

let mk-tactic-or-rule = \name \mkcall-tok \get-name \id \eq-tok {
   if eq-tok /= #< = ># then
      error (name ^ ": expected '=' after " ^ name ^ " name")
   else {
      let tac-id = get-name id
      let s = to_tokens (tokens-to-string id)
      in
      #<
         macro #id = \args {
            join-tokens
               << join-tokens #< trace-with # #$file # #$line # #$column #s { ># (#mkcall-tok #id args)
               << #< } >#
         };
         let #tac-id = \__ipl_facts
      >#
   }
}

macro(2) tactic = \id \eq-tok { mk-tactic-or-rule "tactic" #< mk-tactic-call ># get-tactic-name id eq-tok }
macro(2) rule = \id \eq-tok { mk-tactic-or-rule "rule" #< mk-rule-call ># get-rule-name id eq-tok }

macro call-tactic-with = \args {
   match args with
   | %tac :: %facts :: %t ->
      begin
         let t2 = join-tokens-list t
         let tac2 = get-tactic-name tac
         in
         #< #tac2 #facts #t2 >#
      end
   | %_ -> error "call-tactic-with: wrong arguments"
}

let eval-limit = 1000
let eq-limit = 100

let eq-aux = \f \x \y {
   let aux0 = \x \y \lim0 {
      let aux = \x \y \lim {
         if f x y then
            true
         else if lim = 0 then {
            let xe = eval-limited x eval-limit;
            let ye = eval-limited y eval-limit;
            if f xe ye then
               true
            else {
               match xe, ye with
               | '(%a1 %b1), '(%a2 %b2) ->
                  aux0 a1 a2 (lim0 - 1) and aux0 b1 b2 (lim0 - 1)
               | '(\x %_), '(\x %_) ->
                  var-intro x {
                     aux0 '(xe x) '(ye x) (lim0 - 1)
                  }
               | %_ ->
                  false
            }
         } else {
           let rx = reduce x
           let ry = reduce y
           let xe = reduce-eta x
           let ye = reduce-eta y
           in
           if f rx y or f x ry or f xe y or f xe ry or f x ye or f rx ye then
              true
           else
              aux rx ry (lim - 1)
         }
      };
      if lim0 = 0 then
         false
      else
         aux x y 2
   };
   aux0 x y eq-limit
}

let eq = \x \y . eq-aux (=) x y

let qmatches = \x \y . eq-aux matches x y

let is-in-list = \lst \x {
   List.exists (eq x o goal) lst
}

let find-in-list = \lst \x {
   List.find (eq x o goal) lst ()
}

let check-in-list = \lst \x \emsg {
   let p = find-in-list lst x
   in
   if is-proof p then
      p
   else
      error2 x emsg
}

let match-in-list-acc = \lst \pat \acc {
   List.fold (\h . if qmatches (goal h) pat then h :: acc else acc) lst acc
}

let match-in-list = \lst \pat {
   match-in-list-acc lst pat []
}

/*********************************************************************************/

let verify = \phi \p {
   if eq phi (goal p) then
      proof-of phi
   else
      error2 p ("not a proof of " ^ to_string phi)
}

/*********************************************************************************/

let __ipl_facts = []

/*********************************************************************************/
/* logic rules */

include "logic/core-logic.ipl"

/*********************************************************************************/
/* convenience macros */

include "logic/macros.ipl"

/*********************************************************************************/
/* core proof tactics */

include "tactics/auto-type.ipl"
include "tactics/auto.ipl"
