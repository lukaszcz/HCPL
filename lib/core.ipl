/*
 * Core IPL runtime.
 */

// The core runtime should not contain any definitions that require
// evaluation.

// -------------------------------------------------------------------
//  standard operators

syntax operator neg is right, unary, before appl;

syntax operator not is right, unary, prio appl;

syntax operator *   is left, binary, after appl;
syntax operator /   is left, binary, prio *;
syntax operator div is left, binary, prio *;
syntax operator mod is left, binary, prio *;

syntax operator + is left, binary, after *;
syntax operator - is left, binary, prio +;

syntax operator ^ is left, binary, after +;

syntax operator :: is right, binary, after ^;

syntax operator <  is left, binary, after ::;
syntax operator <= is left, binary, prio <;
syntax operator >  is left, binary, prio <;
syntax operator >= is left, binary, prio <;

syntax operator =  is left, binary, after <;
syntax operator /= is left, binary, prio =;

syntax operator and is left, binary, after =;
syntax operator xor is left, binary, after and;
syntax operator or  is left, binary, after xor;

syntax operator , is right, binary, after or;

syntax operator >> is left, binary, after ,;
syntax operator << is right, binary, prio >>;

syntax operator $. is right, binary, after <<;

syntax block begin end;

let not = \x . if x then false else true;
let neg = \x . 0 - x;
let /=  = \x \y . not (x = y);
let when = \&#x \&#y . if x then y else ();
let >> = \x \f . f x;
let << = \&#f . f;
let $. = <<;

let matches = \x \y . xmatch x y \_ true \_ false;

macro unique-id = \args { #< #$0 ># };

let macro-fun = \f f;

let join-tokens-list = \toks {
   match toks with
   | %h :: %t ->
      join-tokens h (join-tokens-list t)
   | [] -> #< >#
};

let mk-tokens = \toks {
   join-tokens (join-tokens token-tokens-start (join-tokens-list toks)) token-tokens-end
};

let mk-apply = \f \args {
   let aux = \lst {
      match lst with
      | %h :: %t ->
         let r = aux t
         in
         #< #h #r >#
      | [] -> #< >#
   };
   let z = aux args
   in
   #< #f #z >#
};

macro(2) mk-call = \x \y {
   let z = mk-tokens [x]
   in
   #<mk-apply #z #y>#
};

macro mk-macro-call = \args { mk-call mk-call args }
