/* core-logic.ipl: Core illative logic rules.
 *
 * Copyright (C) 2013 by Lukasz Czajka
 */

rule pexpand = \a \p {
   let phi = goal p
   in
   if eq phi (reduce a) or eq phi (reduce-eta a) then
      proof-of a
   else
      error2 (phi, a) "cannot expand"
}

rule preduce = \p {
   proof-of (reduce (goal p))
}

rule preduce-eta = \p {
   proof-of (reduce-eta (goal p))
}

rule peval = \p {
   proof-of (eval (goal p))
}

rule peval-limited = \p \lim {
   proof-of (eval-limited (goal p) lim)
}

let __ipl_suppose_aux = \__ipl_facts \phi \f {
   let p = f ((proof-of phi) :: __ipl_facts)
   in
   match p with
   | proof-of %x -> proof-of '(ASSM phi x)
   | %_ -> error2 p "suppose: expected a proof"
}

macro suppose = \args {
   match args with
   | [%a] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts .. >#
   | [%name, #< : >#, %a] ->
      #< let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts .. >#
   | [%a, %b] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts { #b } >#
   | [%a, #< in >#, %b] ->
      #< __ipl_suppose_aux __ipl_facts #a \__ipl_facts { #b } >#
   | [%name, #< : >#, %a, %b] ->
      #< { let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts { #b } } >#
   | [%name, #< : >#, %a, #< in >#, %b] ->
      #< { let #$0 = #a; let #name = proof-of #$0; __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts { #b } } >#
   | %_ -> error "suppose: wrong arguments"
};

rule impl-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | ('(%b in Prop), '(ASSM %a %x)) ->
      if eq a b then
         proof-of '(a => x)
      else
         error2 p1 "impl-intro: bad typing derivation"
   | %_ -> error2 (p1, p2) "impl-intro: expected a typing derivation and a supposition"
}

rule impl-elim = \p1 \p2 {
   let form = goal p2
   in
   match goal p1 with
   | '(form => %p) -> proof-of p
   | %_ -> error2 p1 "impl-elim: expected implication"
}

rule impl-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi1 in Prop), '(ASSM %phi2 (%psi in Prop)) ->
      if eq phi1 phi2 then
         proof-of '((phi1 => psi) in Prop)
      else
         error2 phi2 "impl-type-intro: wrong argument"
   | '(%phi in Prop), '(%psi in Prop) -> proof-of '((phi => psi) in Prop)
   | %_ -> error2 (p1, p2) "impl-type-intro: wrong arguments"
}

rule impl-type-elim = \p {
   match goal p with
   | '((%a => %_) in Prop) -> proof-of '(a in Prop)
   | %_ -> error2 p "impl-type-elim: wrong argument"
}

rule forall-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) %app)) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '(ALL a1 phi)
            | %_ -> error2 p2 "forall-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "forall-intro: wrong arguments"
   }
};

rule forall-elim = \p1 \p2 {
   match goal p1, goal p2 with
   | ('(ALL %a %phi), '(%t in %a1)) when eq a a1 ->
      proof-of '(phi t)
   | ('(ALL %a %phi), '(%a1 %t)) when eq a a1 ->
      proof-of '(phi t)
   | %_ -> error2 (p1, p2) "forall-elim: wrong arguments"
};

rule forall-type-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) (%app in Prop))) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '((ALL a1 phi) in Prop)
            | %_ -> error2 p2 "forall-type-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "forall-type-intro: wrong arguments"
   }
};

rule exists-intro = \p1 \p2 \p3 {
   match (goal p1, goal p2, goal p3) with
   | ('(%a in Type), '(%t in %a1), '(%phi %t1)) when eq a a1 and eq t t1 ->
      '(EX a phi)
   | %_ -> error2 (p1, p2, p3) "exists-intro: wrong arguments"
};

rule exists-elim = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match (goal p1, goal p2) with
      | ('(EX %a %phi), '(ASSM (x in %a1) (ASSM %app %psi))) when eq a a1 ->
         if occurs-check x psi then
            error2 (p1, p2) "exists-elim: the variable quantified over cannot in the conclusion"
         else {
            match lift app x with
            | '(%phi1 x) when eq phi phi1 -> proof-of psi
            | %_ -> error2 p2 "exists-elim: bad proof"
         }
      | %_ -> error2 (p1, p2) "exists-elim: wrong arguments"
   }
};

rule exists-type-intro = \p1 \f {
   var-intro x {
      let p2 = f x
      in
      match goal p1, goal p2 with
      | ('(%a1 in Type), '(ASSM (x in %a2) (%app in Prop))) when eq a1 a2 ->
         begin
            match lift app x with
            | '(%phi x) -> proof-of '((EX a1 phi) in Prop)
            | %_ -> error2 p2 "exists-type-intro: bad proof"
         end
      | %_ -> error2 (p1, p2) "exists-type-intro: wrong arguments"
   }
}

rule or-intro-left = \p \right {
   let left = goal p
   in
   proof-of '(left or right)
}

rule or-intro-right = \left \p {
   let right = goal p
   in
   proof-of '(left or right)
}

rule or-intro = \x \y {
   match x with
   | proof-of %phi -> or-intro-left x y
   | %_ -> or-intro-right x y
}

rule or-elim = \p \p1 \p2 {
   match (goal p, goal p1, goal p2) with
   | ('(%a or %b), '(ASSM %a1 %c), '(ASSM %b1 %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(%a1 => %c), '(%b1 => %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(ASSM %a1 %c), '(%b1 => %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | ('(%a or %b), '(%a1 => %c), '(ASSM %b1 %c1)) when eq a a1 and eq b b1 and eq c c1 ->
      proof-of c
   | %_ -> error2 (p, p1, p2) "or-elim: wrong arguments"
}

rule or-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi in Prop), '(%psi in Prop) -> proof-of '((phi or psi) in Prop)
   | %_ -> error2 (p1, p2) "or-type-intro: wrong arguments"
}

rule and-intro = \p1 \p2 {
   let a = goal p1
   let b = goal p2
   in
   proof-of '(a and b)
}

rule and-elim-left = \p {
   match goal p with
   | '(%a and %_) -> proof-of a
   | %_ -> error2 p "and-elim-left: wrong argument"
}

rule and-elim-right = \p {
   match goal p with
   | '(%_ and %b) -> proof-of b
   | %_ -> error2 p "and-elim-right: wrong argument"
}

rule and-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a in Prop), '(%b in Prop) -> proof-of '((a and b) in Prop)
   | %_ -> error2 (p1, p2) "and-type-intro: wrong arguments"
}

rule equiv-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi => %psi), '(%psi1 => %phi1) when eq phi phi1 and eq psi psi1 -> proof-of '(phi <=> psi)
   | %_ -> error2 (p1, p2) "equiv-intro: wrong arguments"
}

rule equiv-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%phi in Prop), '(%psi in Prop) ->
      proof-of '((phi <=> psi) in Prop)
   | '(ASSM %psi1 (%phi in Prop)), '(ASSM %phi1 (%psi in Prop)) when eq psi psi1 and eq phi phi1 ->
      proof-of '((phi <=> psi) in Prop)
   | '(ASSM %psi1 (%phi in Prop)), '(%psi in Prop) when eq psi psi1 ->
      proof-of '((phi <=> psi) in Prop)
   | '(%phi in Prop), '(ASSM %phi1 (%psi in Prop)) when eq phi phi1 ->
      proof-of '((phi <=> psi) in Prop)
   | %_ ->
      error2 (p1, p2) "equiv-type-intro: wrong arguments"
}

rule equiv-elim = \p1 \p2 {
   match goal p1 with
   | '(%phi <=> %psi) when eq phi (goal p2) -> proof-of psi
   | '(%phi <=> %psi) when eq psi (goal p2) -> proof-of phi
}

rule false-elim = \phi \p {
   match p with
   | proof-of false -> proof-of phi
   | %_ -> error2 p "false-elim: wrong argument"
}

rule not-intro-2 = \p1 \p2 {
   match (goal p1, goal p2) with
   | ('(%a in Prop), '(ASSM %a1 false)) when eq a a1 ->
      proof-of '(not a)
   | %_ -> error2 (p1, p2) "not-intro-2: wrong arguments"
}

macro(1) not-intro-1 = \p #<{
   let #$0 = #p
   in
   match goal #$0 with
   | '(ASSM %a false) ->
      not-intro-2 (auto-type '(a in Prop)) #$0
   | %_ -> error2 #$0 "not-intro-1: wrong argument"
}>#

macro not-intro = \args {
   match args with
   | [%x] -> #< not-intro-1 #x >#
   | [%x, %y] -> #< not-intro-2 #x #y >#
   | %_ -> error "not-intro: wrong arguments"
}

rule not-elim = \p1 \p2 {
   let a = goal p1;
   let b = goal p2;
   if eq a '(not b) or eq '(not a) b then
      proof-of false
   else
      error2 (p1, p2) "not-elim: wrong arguments"
}

rule not-type-intro = \p {
   match goal p with
   | '(%g in Prop) -> proof-of '((not g) in Prop)
   | %_ -> error2 p "not-type-intro: wrong argument"
}

rule not-type-elim = \p {
   match goal p with
   | '((not %a) in Prop) -> proof-of '(a in Prop)
   | %_ -> error2 p "not-type-elim: wrong argument"
}

rule contradiction = \p {
   match goal p with
   | '((not %x) => false) -> proof-of x
   | '(not (not %x)) -> proof-of x
   | '((%x => false) => false) -> proof-of x
   | %_ -> error2 p "contradiction: wrong argument"
}

rule prop-intro = \p {
   let phi = goal p
   in
   proof-of '(phi in Prop)
}

let prop-type-intro = proof-of '(Prop in Type)

rule fun-type-intro = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a in Type), '(%b in Type) -> proof-of '((a -> b) in Type)
   | %_ -> error2 (p1, p2) "fun-type-intro: wrong arguments"
}

rule equal-intro = \a \b {
   if eq a b then
      proof-of '(a = b)
   else
      error2 (a, b) "equal-intro: not equal"
}

rule equal-elim = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%phi %b1) when eq b b1 -> proof-of '(phi a)
   | %_ -> error2 (p1, p2) "equal-elim: wrong arguments"
}

rule equal-sym = \p {
   match goal p with
   | '(%a = %b) -> proof-of '(b = a)
   | %_ -> error2 p "equal-sym: wrong argument"
}

rule equal-trans = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%b1 = %c) when eq b b1 -> proof-of '(a = c)
   | %_ -> error2 (p1, p2) "equal-trans: wrong arguments"
}

rule equal-cong = \p1 \p2 {
   match goal p1, goal p2 with
   | '(%a = %b), '(%c = %d) -> proof-of '(a c = b d)
   | %_ -> error2 (p1, p2) "equal-cong: wrong arguments"
}

rule bool-ext-true = \p {
   let g = goal p
   in
   proof-of '(g = true)
}

rule bool-ext-false = \p {
   match goal p with
   | '(not %a) -> '(a = false)
   | %_ -> error2 p "bool-ext-false: wrong argument"
}

let false-type-intro = proof-of '(false in Prop)
let true-type-intro = proof-of '(true in Prop)

let true-intro = proof-of true

let faith = proof-of

macro(0) facts = \_ { #< __ipl_facts ># }

macro(1) fact = \phi #<
   trace-with #$file #$line #$column "fact"
      (check-in-list __ipl_facts #phi "not a known fact")
>#
macro(1) is-fact = \x #< is-in-list __ipl_facts #x >#
macro(1) find-fact = \x #< find-in-list __ipl_facts #x >#
macro(1) match-facts = \pat #< match-in-list __ipl_facts #pat >#

macro(1) remember = \p #< let #$0 = #p in (#$0 :: __ipl_facts) >> \__ipl_facts .. #$0 >#
