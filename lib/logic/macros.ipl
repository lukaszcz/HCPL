/* macros.ipl: Convenience logic macros.
 *
 * Copyright (C) 2013 by Lukasz Czajka
 */

macro assume = \args {
   let get-block = \lst {
      match List.rev lst with
      | %b :: #< in ># :: %_ -> b
      | %_ -> ()
   };
   let get-type = \lst {
      match List.rev lst with
      | %_ :: #< in ># :: %t -> join-tokens-list (List.rev t)
      | %_ -> join-tokens-list lst
   };
   let aux = \name \assm \tp \block {
      let tp2 = if tp = () then #< (auto-type '(#$0 in Prop)) ># else tp;
      if name = () and block = () then
         #< let #$0 = #assm in impl-intro #tp2 << __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts .. >#
      else if name = () then
         #< { let #$0 = #assm in impl-intro #tp2 (suppose #$0 #block) } >#
      else if block = () then
         #<
            let #$0 = #assm;
            let #name = proof-of #$0;
            impl-intro #tp2 << __ipl_suppose_aux __ipl_facts #$0 \__ipl_facts ..
         >#
      else
         #< { let #$0 = #assm in impl-intro #tp2 (suppose #name : #$0 #block) } >#
   };
   match args with
   | [%a] ->
      aux () a () ()
   | [%name, #< : >#, %a] ->
      aux name a () ()
   | %name :: #< : ># :: %a :: #< with ># :: %t ->
      aux name a (get-type t) (get-block t)
   | [%name, #< : >#, %a, #< in >#, %b] ->
      aux name a () b
   | [%name, #< : >#, %a, %b] ->
      aux name a () b
   | %a :: #< with ># :: %t ->
      aux () a (get-type t) (get-block t)
   | [%a, %b] ->
      aux () a () b
   | [%a, #< in >#, %b] ->
      aux () a () b
   | %_ ->
      error "assume: wrong arguments"
};

macro fix = \args {
   let aux = \vars \tp \tp-deriv \body {
      match vars with
      | %h :: %t ->
         let r = aux t tp tp-deriv body
         in
         #< forall-intro #tp-deriv \#h .. suppose '(#h in #tp); #r >#
      | [] -> body
   };
   match List.split-once (= #< : >#) args with
   | [%lst1, %lst2] ->
      let vars =
         List.map (\x . match x with [%y] -> y | %_ -> error "fix: wrong arguments")
         <<
         List.split (= #< , >#) lst1
      in
      begin
         match List.split-once (= #< with >#) lst2 with
         | [%_] ->
            begin
               match List.split-once (= #< in >#) lst2 with
               | [%_] ->
                  let tp = join-tokens-list lst2
                  in
                  aux vars tp #< (auto-type '(#tp in Type)) ># #< >#
               | [%a, %b] ->
                  let tp = join-tokens-list a
                  in
                  let body = join-tokens-list b
                  in
                  let r = aux vars tp #< (auto-type '(#tp in Type)) ># body
                  in
                  #< (#r) >#
               | %_ -> error "fix: wrong arguments"
            end
         | [%lst3, %lst4] ->
            begin
               let tp = join-tokens-list lst3
               in
               match List.split-once (= #< in >#) lst4 with
               | [%_] ->
                  let tp-deriv = join-tokens-list lst4
                  in
                  aux vars tp tp-deriv #< >#
               | [%a, %b] ->
                  let tp-deriv = join-tokens-list a
                  in
                  let body = join-tokens-list b
                  in
                  let r = aux vars tp tp-deriv body
                  in
                  #< (#r) >#
               | %_ -> error "fix: wrong arguments"
            end
         | %_ -> error "fix: wrong arguments"
      end
   | %_ -> error "fix: wrong arguments"
};

macro obtain = \args {
   let aux = \v \p \b {
      if b = () then
         #<
            let #$0 = $p
            in
            exists-elim #p \#v ..
               let #$1 =
                  match goal #$0 with
                  | '(EX %alpha %phi) -> (alpha, phi)
                  | %_ -> error2 #$0 "obtain: expected a proof of an existential formula"
               in
               let #$2 = fst #$1;
               let #$3 = snd #$1;
               suppose '(#v in #$2);
               suppose '(#$3 #v);
         >#
      else
         #<{
            let #$0 = $p
            in
            exists-elim #p \#v {
               match goal #$0 with
               | '(EX %alpha %phi) ->
                  begin
                     suppose '(#v in alpha);
                     suppose '(phi #v);
                     #b
                  end
               | %_ ->
                  error2 #$0 "obtain: expected a proof of an existential formula"
            }
         }>#
   };
   match args with
   | %v :: #< from ># :: %t ->
      begin
         match List.split-once (= #< in >#) t with
         | [%_] ->
            let p = join-tokens-list t
            in
            aux v p ()
         | [%lst1, %lst2] ->
            let p = join-tokens-list lst1
            in
            let b = join-tokens-list lst2
            in
            aux v p b
         | %_ ->
            error "obtain: wrong arguments"
      end
   | [%v, %p, %b] ->
      aux v p b
   | [%v, %p] ->
      aux v p ()
   | %_ -> error "obtain: wrong arguments"
};

macro lemma = \args {
   match args with
   | [%name, %formula, %xproof] ->
      #<
         let #$0 = #formula;
         let #name = { let thesis = #$0; (#xproof) };
         remember (verify #$0 #name)
      >#
   | [%formula, %xproof] ->
      #<
         let #$0 = #formula;
         let #$1 = { let thesis = #$0; (#xproof) };
         remember (verify #$0 #$1)
      >#
   | %_ -> error "lemma: wrong arguments"
}

macro theorem = \args { mk-macro-call (lemma) args }

macro axiom = \args {
   match args with
   | [%phi] -> #< (proof-of #phi :: __ipl_facts) >> \__ipl_facts .. >#
   | %_ -> error "axiom: wrong arguments"
}

let __ipl_ex_all_aux = \args \quant \msg {
   match List.split-once (= #< : >#) args with
   | [%lst1, %lst2] ->
      begin
         let pr =
            begin
               match List.split-once (= #< . >#) lst2 with
               | [%_] ->
                  let len = List.length lst2
                  in
                  (join-tokens-list (List.head lst2 (len - 1)), List.nth lst2 (len - 1))
               | [%lst3, %lst4] ->
                  (join-tokens-list lst3, join-tokens-list lst4)
               | %_ -> error msg
            end
         in
         let tp = fst pr;
         let rest = snd pr;
         let aux = \lst {
            match lst with
            | [%x] :: %t ->
               join-tokens #< #quant (#tp) \#x . ># (aux t)
            | [] -> #< >#
            | %_ -> error msg
         };
         let h = aux (List.split (= #< , >#) lst1)
         in
         #< #h #rest >#
      end
   | %_ -> error msg
}

macro ex = \args { __ipl_ex_all_aux args #< EX ># "exists: wrong arguments" }
macro all = \args { __ipl_ex_all_aux args #< ALL ># "forall: wrong arguments" }

macro exists = \args { mk-macro-call ex args }
macro forall = \args { mk-macro-call all args }

macro show = \args {
   let aux = \name \formula \p {
      if name = () then
         #< remember (let #$0 = #formula in verify #$0 #p) >#
      else
         #< let #$0 = #formula in let #name = verify #$0 #p in remember #name >#
   };
   let pr =
      match args with
      | %name :: #< : ># :: %rest -> (name, rest)
      | %_ -> ((), args)
   in
   let name = fst pr
   let lst0 = snd pr
   in
   match lst0 with
   | %formula :: #< by ># :: %lst1 ->
      begin
         match lst1 with
         | %tac :: #< from ># :: %lst2 ->
            let facts = join-tokens-list lst2
            in
            aux name formula #< (call-tactic-with #tac [ #facts ] #$0) >#
         | [%tac] ->
            aux name formula #< (#tac #$0) >#
         | %_ ->
            error "show: wrong arguments"
      end
   | %formula :: #< with ># :: %lst1 ->
      let p = join-tokens-list lst1
      in
      aux name formula #< (#p) >#
   | %formula :: #< from ># :: %lst1 ->
      let facts = join-tokens-list lst1
      in
      aux name formula #< (call-tactic-with auto [ #facts ] #$0) >#
   | [%formula] ->
      aux name formula #< (auto #$0) >#
   | %_ ->
      error "show: wrong arguments"
};
